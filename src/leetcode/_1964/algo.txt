1. Создаем 4 переменные n,  lisLength, []answer, []lis, где n - длина входного массива, lisLength = 0, []answer - результирующий
массив длины n, lis - массив длины n
2. Обходим в цикле все элементы входного массива
2.1 Сохраняем текущий элемент массива в переменную height
2.2 Создаем пеменную int idx, для вычисления которого нужен метод bisect(lis, height, lisLength);
2.3 Создаем метод bisect, у которого выходные параметры - массив, target, right
2.4. bisect. Проверяем если right == 0, то возвращаем 0
2.5. bisect. Создаем переменную int left = 0
2.6 bisect. Начинаем цикл для двоичного поиска со строгим условием left < right
2.7 bisect. Находим среднуюю позицию
2.8 bisect. Если элемент массива в средней позиции меньше или равно target, то обрезаем левый указатель +1
2.9 bisect. Иначе обрезаем правый
2.10 bisect. После цикла возвращаем left
2.11 Если idx == lisLength, то икнрементируем lisLength
2.12 Присваиваем lis[idx] = height;
2.13 Присваиваем answer[i] = idx+1;
2.14 Возвращаем результирующий массив